(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{223:function(t,a,s){"use strict";s.r(a);var i=s(0),e=Object(i.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),s("h2",{attrs:{id:"强缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("强缓存主要是通过http请求头中的Expire、Pragma、Cache-Control字段控制")])]),t._v(" "),s("h3",{attrs:{id:"expires-http1-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#expires-http1-0"}},[t._v("#")]),t._v(" Expires(HTTP1.0)")]),t._v(" "),s("p",[t._v("Expires的值表示服务端返回资源的到期的时间点。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),s("p",[t._v("服务端时间和客户端时间可能有误差，客户端时间也会被用户更改, 会导致缓存命中的误差")])]),t._v(" "),s("p",[t._v("Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。")]),t._v(" "),s("h3",{attrs:{id:"pragma-http1-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pragma-http1-0"}},[t._v("#")]),t._v(" Pragma(HTTP1.0)")]),t._v(" "),s("p",[t._v("Pragma: no-cache. 与 Cache-Control: no-cache 效果一致。强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行验证。")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),s("p",[t._v("由于 Pragma 在 HTTP 响应中的行为没有确切规范，所以不能可靠替代 HTTP/1.1 中通用首部 Cache-Control，尽管在请求中，假如Cache-Control不存在的话，它的行为与Cache-Control: no-cache一致。建议只在需要兼容 HTTP/1.0客户端的场合下应用Pragma首部。   ——MDN")])]),t._v(" "),s("h3",{attrs:{id:"cache-control-http1-1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cache-control-http1-1"}},[t._v("#")]),t._v(" Cache-Control(HTTP1.1)")]),t._v(" "),s("ul",[s("li",[t._v("private：客户端可以缓存")]),t._v(" "),s("li",[t._v("public：客户端和代理服务器都可以缓存")]),t._v(" "),s("li",[t._v("max-age=t：缓存内容将在t秒后失效")]),t._v(" "),s("li",[t._v("no-cache：需要使用协商缓存来验证缓存数据")]),t._v(" "),s("li",[t._v("no-store：所有内容都不会缓存")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("当在首部字段Cache-Control有指定max-age指令时，比起首部字段 Expires，会优先处理max-age指令。命中强缓存的表现形式：Firefox浏览器表现为一个灰色的200状态码。Chrome浏览器状态码表现为200 (from disk cache)或是200 OK (from memory cache)。")])]),t._v(" "),s("h2",{attrs:{id:"协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),s("p",[t._v("协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了")]),t._v(" "),s("h3",{attrs:{id:"last-modified"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[t._v("#")]),t._v(" Last-Modified")]),t._v(" "),s("p",[t._v("服务端返回资源时带上的资源最后修改时间，当客户端再次请求的时候会在缓存中取出参数并在以下字段带上")]),t._v(" "),s("ul",[s("li",[t._v("if-Modified-Since")])]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),s("p",[t._v("If-Modified-Since 只可以用在 GET 或 HEAD 请求中。当与If-None-Match一同出现时，它(If-Modified-Since)会被忽略掉，除非服务器不支持 If-None-Match。")])]),t._v(" "),s("p",[t._v("服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比。如果一致则返回304 Not Modified和响应报文头，浏览器只需要从缓存中获取信息即可;如果不一致，则开始传输响应一个整体，服务器返回：200 OK")]),t._v(" "),s("ul",[s("li",[t._v("if-Unmodified-Since")])]),t._v(" "),s("p",[t._v("从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。\n如果没有被修改：则开始继续传送文件，服务器返回: 200 OK。\n如果所请求的资源在指定的时间之后发生了修改，那么会返回412(Precondition Failed)预备条件错误。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("使用场景 ——MDN")]),t._v(" "),s("p",[t._v("与 non-safe 方法如POST搭配使用，可以用来优化并发控制，例如在某些wiki应用中的做法：假如在原始副本获取之后，服务器上所存储的文档已经被修改，那么对其作出的编辑会被拒绝提交。\n与含有 If-Range 消息头的范围请求搭配使用，用来确保新的请求片段来自于未经修改的文档。")])]),t._v(" "),s("h3",{attrs:{id:"etag-entity"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#etag-entity"}},[t._v("#")]),t._v(" Etag(Entity)")]),t._v(" "),s("p",[t._v("服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）\n前面可以加上 W/ 前缀表示应该采用弱比较算法。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("Nginx默认的Etag为：16进制last-modified-time-16进制文件大小")])]),t._v(" "),s("ul",[s("li",[t._v("If-Match\n在请求方法为 GET 和 HEAD 的情况下，服务器仅在请求的资源满足此首部列出的 ETag值时才会返回资源，否则返回416 (Range Not Satisfiable，范围请求无法满足)响应。\n对于 PUT 或其他非安全方法来说，只有在满足条件的情况下才可以将资源上传，如果请求的条件不满足，否则返回412(Precondition Failed，先决条件失败) 响应。")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("使用场景 ——MDN")]),t._v(" "),s("p",[t._v("对于GET和HEAD方法，搭配Range首部使用，可以用来保证新请求的范围与之前请求的范围是对同一份资源的请求。\n对于其他方法来说，尤其是 PUT, If-Match 首部可以用来避免更新丢失问题。它可以用来检测用户想要上传的不会覆盖获取原始资源之后做出的更新。")])]),t._v(" "),s("ul",[s("li",[t._v("If-None-Match")])]),t._v(" "),s("p",[t._v("不同，说明资源被改动过，则响应整个资源内容，返回状态码200。\n相同，说明资源没有修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.")]),t._v(" "),s("p",[t._v("参考文章："),s("a",{attrs:{href:"https://juejin.im/post/5d690c726fb9a06b155dd40d#heading-33",target:"_blank",rel:"noopener noreferrer"}},[t._v("缓存-子弈"),s("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);