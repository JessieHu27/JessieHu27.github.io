(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{211:function(t,e,r){"use strict";r.r(e);var a=r(0),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"http、https与http2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http、https与http2"}},[t._v("#")]),t._v(" HTTP、HTTPS与HTTP2")]),t._v(" "),r("h2",{attrs:{id:"http1-0与http1-1"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http1-0与http1-1"}},[t._v("#")]),t._v(" HTTP1.0与HTTP1.1")]),t._v(" "),r("p",[t._v("HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：")]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("缓存处理")]),t._v("，在HTTP1.0中主要使用header里的If-Modified-Since,Expires,Pragam来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("带宽优化及网络连接的使用")]),t._v("，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("错误通知的管理")]),t._v("，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("Host头处理")]),t._v("，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web  Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("长连接")]),t._v("，HTTP  1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。")])])]),t._v(" "),r("h2",{attrs:{id:"https"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),r("p",[t._v("HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。HTTPS主要作用是：")]),t._v(" "),r("ul",[r("li",[t._v("对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全")]),t._v(" "),r("li",[t._v("对网站服务器进行真实身份认证")])]),t._v(" "),r("h3",{attrs:{id:"证书获得的过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#证书获得的过程"}},[t._v("#")]),t._v(" 证书获得的过程")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("服务方S向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证")])]),t._v(" "),r("li",[r("p",[t._v("CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等")])]),t._v(" "),r("li",[r("p",[t._v("如信息审核通过，CA会向申请者签发认证文件-证书")])])]),t._v(" "),r("h3",{attrs:{id:"ca证书的内容"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ca证书的内容"}},[t._v("#")]),t._v(" CA证书的内容")]),t._v(" "),r("ul",[r("li",[t._v("包含申请者公钥、申请者的组织信息和个人信息、签发机构、CA的信息、有效时间、证书序列号等信息的明文")]),t._v(" "),r("li",[t._v("数字签名（ 签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名）")])]),t._v(" "),r("h3",{attrs:{id:"https请求的过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#https请求的过程"}},[t._v("#")]),t._v(" HTTPS请求的过程")]),t._v(" "),r("ol",[r("li",[t._v("客户端 C 向服务器 S 发出请求时，S 返回证书文件;")]),t._v(" "),r("li",[t._v("客户端 C读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法;")]),t._v(" "),r("li",[t._v("客户端然后验证证书相关的域名信息、有效时间等信息; 如果证书验证通过也开始发起https请求，否则会提示用户证书不安全")])]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),r("p",[t._v("客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。")])]),t._v(" "),r("h2",{attrs:{id:"http2的新特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http2的新特性"}},[t._v("#")]),t._v(" HTTP2的新特性")]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("新的二进制格式")]),t._v("（Binary Format），HTTP1.x  的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1  的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("多路复用")]),t._v("（MultiPlexing），即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据  request 的 id 将 request 再归属到各自不同的服务端请求里面。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("header 压缩")]),t._v("，如上文中所言，对前面提到过 HTTP1.x 的 header  带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份  header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("服务端推送")]),t._v("（server push）")])])]),t._v(" "),r("p",[t._v("参考：")]),t._v(" "),r("ul",[r("li",[r("p",[r("a",{attrs:{href:"https://juejin.im/post/5af557a3f265da0b9265a498#heading-37",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP和HTTPS"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA",target:"_blank",rel:"noopener noreferrer"}},[t._v("一个故事讲完HTTPS"),r("OutboundLink")],1)])])])])}),[],!1,null,null,null);e.default=s.exports}}]);