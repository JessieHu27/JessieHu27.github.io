(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{213:function(t,e,s){"use strict";s.r(e);var a=s(0),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[t._v("#")]),t._v(" 跨域")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("请求的协议、IP和端口不一致都是跨域行为。浏览器有同源策略限制，不允许跨域访问资源。")])]),t._v(" "),s("h2",{attrs:{id:"jsonp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsonp"}},[t._v("#")]),t._v(" JSONP")]),t._v(" "),s("p",[t._v("前端事先定义一个获取跨域响应的回调函数，在script标签没有跨域限制的基础上，通过设置标签的src为请求地址，并在url中带上请求的参数和回调函数名，\n后台拿到请求数据后执行处理，以回调函数执行为返回结果，并将返回的数据放到回调函数中。前端请求成功后回调函数立即执行，就拿到了请求数据。")]),t._v(" "),s("p",[t._v("缺点及其解决方案：")]),t._v(" "),s("ul",[s("li",[t._v("只能用GET请求，url长度有限制。可以设置浏览器或WEB服务器对GET请求长度的尽可能大")]),t._v(" "),s("li",[t._v("容易引起CSRF攻击。比如前端构造一个恶意页面，请求JSONP接口，收集服务端的敏感信息。Referer监测")]),t._v(" "),s("li",[t._v("XSS漏洞。定义Content-type:application/json并对返回参数进行转义操作")])]),t._v(" "),s("h2",{attrs:{id:"cors"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cors"}},[t._v("#")]),t._v(" CORS")]),t._v(" "),s("p",[t._v("CORS（跨域资源共享 Cross-origin resource sharing）允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服跨域问题，它需要浏览器和服务器的同时支持。")]),t._v(" "),s("ul",[s("li",[t._v("浏览器端会自动向请求头添加origin字段，表明当前请求来源。")]),t._v(" "),s("li",[t._v("服务器端需要设置响应头的Access-Control-Allow-Methods，Access-Control-Allow-Headers，Access-Control-Allow-Origin等字段，指定允许的方法，头部，源等信息。")]),t._v(" "),s("li",[t._v("请求分为简单请求和非简单请求，非简单请求会先进行一次OPTION方法进行预检，看是否允许当前跨域请求。")])]),t._v(" "),s("h3",{attrs:{id:"简单请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简单请求"}},[t._v("#")]),t._v(" 简单请求")]),t._v(" "),s("ul",[s("li",[t._v("HEAD")]),t._v(" "),s("li",[t._v("GET")]),t._v(" "),s("li",[t._v("POST")])]),t._v(" "),s("p",[t._v("HTTP的请求头信息不超出以下几种字段：")]),t._v(" "),s("ul",[s("li",[t._v("Accept")]),t._v(" "),s("li",[t._v("Accept-Language")]),t._v(" "),s("li",[t._v("Content-Language")]),t._v(" "),s("li",[t._v("Last-Event-ID")]),t._v(" "),s("li",[t._v("Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain")])]),t._v(" "),s("p",[t._v("后端的响应头信息：")]),t._v(" "),s("ul",[s("li",[t._v("Access-Control-Allow-Origin：该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。")]),t._v(" "),s("li",[t._v("Access-Control-Allow-Credentials：该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。")]),t._v(" "),s("li",[t._v("Access-Control-Expose-Headers：该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。")])]),t._v(" "),s("h3",{attrs:{id:"非简单请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非简单请求"}},[t._v("#")]),t._v(" 非简单请求")]),t._v(" "),s("p",[t._v('非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。')]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。")])]),t._v(" "),s("li",[s("p",[t._v("Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。")])])]),t._v(" "),s("p",[t._v('如果浏览器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。\nJSONP和CORS的对比')]),t._v(" "),s("h2",{attrs:{id:"nginx反向代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nginx反向代理"}},[t._v("#")]),t._v(" Nginx反向代理")]),t._v(" "),s("h2",{attrs:{id:"postmessage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#postmessage"}},[t._v("#")]),t._v(" postMessage")])])}),[],!1,null,null,null);e.default=r.exports}}]);